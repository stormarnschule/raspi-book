<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>RPi Dokumentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Raspberry Pi - Dokumentation von der Stormarnschule">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="introduction/index.html"><strong>1.</strong> Einführung</a></li><li><ul class="section"><li><a href="introduction/ssh.html"><strong>1.1.</strong> SSH-Verbindung</a></li></ul></li><li><a href="installation/index.html"><strong>2.</strong> Installation</a></li><li><ul class="section"><li><a href="installation/os.html"><strong>2.1.</strong> Betriebssystem</a></li><li><a href="installation/software.html"><strong>2.2.</strong> Software</a></li></ul></li><li><a href="basics/index.html"><strong>3.</strong> Grundlagen</a></li><li><ul class="section"><li><a href="basics/rpi.html"><strong>3.1.</strong> Raspberry Pi</a></li><li><a href="basics/gpio.html"><strong>3.2.</strong> GPIO</a></li><li><a href="basics/gertboard.html"><strong>3.3.</strong> Gertboard</a></li></ul></li><li><a href="tutorials/index.html"><strong>4.</strong> Tutorials</a></li><li><ul class="section"><li><a href="tutorials/simple/index.html"><strong>4.1.</strong> Einfach</a></li><li><ul class="section"><li><a href="tutorials/simple/led.html"><strong>4.1.1.</strong> LED</a></li><li><a href="tutorials/simple/button.html"><strong>4.1.2.</strong> Taster</a></li></ul></li><li><a href="tutorials/gertboard/index.html"><strong>4.2.</strong> Gertboard</a></li><li><ul class="section"><li><a href="tutorials/gertboard/lights.html"><strong>4.2.1.</strong> Lichtorgel</a></li><li><a href="tutorials/gertboard/buttons.html"><strong>4.2.2.</strong> Taster</a></li><li><a href="tutorials/gertboard/lights-buttons.html"><strong>4.2.3.</strong> Lichtorgel + Taster</a></li></ul></li><li><a href="tutorials/lcd/index.html"><strong>4.3.</strong> LCD</a></li><li><ul class="section"><li><a href="tutorials/lcd/snake.html"><strong>4.3.1.</strong> Spiel: Snake</a></li><li class="spacer"></li></ul></li></ul></li><li><a href="meta.html">Meta</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">RPi Dokumentation</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Einführung</h1>
<p><strong>Willkommen auf der Projektseite</strong> des Informatikunterrichtes 15/16 an der
<a href="http://stormarnschule.de/">Stormarnschule Ahrensburg</a>.</p>
<p>Diese Webseite wurde zu Dokumentationszwecken für nachfolgende Informatiklehrer
und -schüler erstellt, um einen einfachen Einstieg in das Thema zu bieten. Bis
Sommer 2016 wird diese Webseite erweitert und verbessert, wer sich danach darum
kümmert steht nicht fest.</p>
<p>Aktuell werden Inhalte von Fabian Pieper und Jesse Stricker erstellt, welche
auf der Arbeit mit dem Raspberry Pi im Unterricht basieren.</p>
<p>Auf dieser Seite finden sich alle <strong>Tutorials und Anleitungen</strong>, die im
Unterricht entstanden sind.</p>
<h2>Für Einsteiger</h2>
<p>Schüler, die den Raspberry Pi zum ersten Mal verwenden, sollten dieser
Dokumenatation von Anfang bis Ende folgen, um einen möglichst einfachen Einstieg
in das Thema zu bekommen.</p>
<p>Es wird sich zu erst mit dem Einrichten des Raspberry Pi beschäftigt, bevor es
mit Texten zu den Grundlagen weiter geht.<br />
Wenn dann ein gewisses Grundverständnis vorhanden ist, können die Tutorials
bearbeitet werden.</p>
<h2>Für Fortgeschrittene</h2>
<p>Wer in dem Umgang mit dem Raspberry Pi schon geübter ist, kann sich direkt an
die Tutorials setzen. In dem Fall ist ein Grundwissen von C++ benötigt.</p>
<h2>Für zur Dokumentation Beitragende</h2>
<p>Für Euch findet sich unter dem Appendix <a href="meta.html">Meta</a> eine Zusammenfassung,
wie diese Dokumentation ensteht und welche Werkzeuge dafür verwendet werden.</p>
<p>Bitte lest sie euch vorher durch, damit der Stil der Dokumentation möglichst
konstant bleibt. Danke.</p>
<h1>SSH-Verbindung</h1>
<p>Das Herstellen einer SSH-Verbindung zum Rasperry Pi ist sehr nützlich zum
Ausführen von Befehlen. Man kann sich dann das anschließen von Monitor und
Tastatur an den Pi sparen und vom eigenem Laptop oder Schulrecher aus den
Pi steuern.</p>
<p>Je nach Betriebsystem ist das Verbinden zum Pi unterschiedlich. Dise Anleitung
gilt für Linux, OSX und Windows.</p>
<h2>Verbindung aufbauen</h2>
<h3>Linux, OSX</h3>
<p>OSX basiert auf Linux und da Linux einen SSH-Klienten mitbringt, gelten diese
Schritte auch für OSX.</p>
<ol>
<li>
<p>Öffne das Terminal</p>
</li>
<li>
<p>Führe folgenden Befehl aus:</p>
<pre><code>ssh pi@&lt;ip&gt;
</code></pre>
<p><strong>&lt;ip&gt;</strong> ist durch die IP-Addresse oder den Hostnamen des Raspberry Pis zu
ersetzten.</p>
</li>
<li>
<p>Du bist nun auf dem Raspberry Pi und die Befehle, die du schreibt, werden
direkt auf dem Pi ausgeführt</p>
</li>
<li>
<p>Um zu Beenden, schließe entweder einfach das Terminal oder sende <code>exit</code> an
den Pi, um zum Terminal deines PCs zurückzukehren</p>
</li>
</ol>
<h3>Windows</h3>
<p>Anders als vorher hat Windows keinen eigenen SSH-Klienten, deshalb müssen wir
uns einen herunterladen und installieren.</p>
<ol>
<li>Lade <a href="the.earth.li/%7Esgtatham/putty/latest/x86/putty.exe">Putty</a> herunter und
ziehen es an einen geeigneten Ort, z.B. den Desktop</li>
<li>Starte Putty</li>
<li>Gib in das Feld <code>Host Name (or IP Address)</code> folgendes ein: <code>pi@&lt;ip&gt;</code>.<br />
<strong>&lt;ip&gt;</strong> ist durch die IP-Addresse oder den Hostnamen des Raspberry Pis zu
ersetzten</li>
<li>Drücke Enter oder klicke auf <strong>Open</strong> unten rechts</li>
<li>Du bist nun auf dem Raspberry Pi und die Befehle, die du schreibt, werden
direkt auf dem Pi ausgeführt</li>
<li>Zum Beenden kannst du einfach das Putty-Fenster schließen</li>
</ol>
<h1>Installation</h1>
<p>Bei einem neuem Raspberry Pi ist kein Speicher dabei, es muss also eine SD-Karte
mit einem Betriebssystem bespielt werden, von dem der Raspberry Pi aus läuft.</p>
<p>Wie das erledigt wird, und wie das Betriebssystem eingerichtet wird, seht ihr
auf den nächsten Seiten.</p>
<h1>Betriebssystem</h1>
<p>Zum Installieren werden ein paar Dinge benötigt, die vorher behandelt werden
sollten:</p>
<ul>
<li>SD-Karte, <strong>4 GB oder mehr</strong></li>
<li>Win32 Disk Imager</li>
<li>Raspberry Pi</li>
<li>Computer mit SD-Kartenleser</li>
</ul>
<p>Das Betriebsystem des Raspberry Pis ist eine angepasste Linux-Distribution, die von dem
populärem <a href="https://www.debian.org">Debian</a> abstammt, daher auch der Name &quot;Raspbian&quot;.
Wir nutzen &quot;Raspbian Lite&quot;, eine minimale Version ohne Desktopoberfläche, nur mit
Eingabeaufforderung.</p>
<h2>Download</h2>
<p>Als erstes muss das Datenträgerabbild von der Raspberry Pi Webseite heruntergeladen werden.
Ihr findet es <a href="https://www.raspberrypi.org/downloads/raspbian/">auf der Downloadseite</a>.
Am Besten ladet ihr immer das Aktuellste herunter, wenn ihr einen Pi neu aufsetzt, dieses
seht ihr auf der linken Seite:
<strong><a href="https://downloads.raspberrypi.org/raspbian_lite_latest">Direktlink</a></strong></p>
<p>Nach dem ihr die ZIP-Datei heruntergeladen habt, müsst ihr diese entpacken: Ihr erhaltet
eine <strong>.IMG</strong> Datei, das Datenträgerabbild.</p>
<h2>SD-Karte formatieren</h2>
<p>Für das Kopieren des Images (Datenträgerabbildes) ist ein Programm wie
<a href="http://sourceforge.net/projects/win32diskimager/files/Archive/Win32DiskImager-0.9.5-binary.zip/download">Win32 Disk Imager</a>
benötigt, welches den Inhalt auf die SD-Karte schreibt.</p>
<p>Startet das Programm nach Download &amp; Entpacken mit <strong>Administratorrechten</strong>. Dies ist
wichtig, da das Schreiben sonst unter Umständen nicht funktioniert!</p>
<ol>
<li>Rechtsklick auf &quot;Win32DiskImager.exe&quot;</li>
<li>Klick auf &quot;Als Administrator ausführen&quot;</li>
</ol>
<p>Wenn Win32 Disk Imager läuft:</p>
<ol>
<li>Klick auf den kleinen, blauen Ordner rechts</li>
<li>Image (.IMG Datei) auswählen und bestätigen</li>
<li>Rechts unter &quot;Device&quot; die SD-Karte auswählen,
den Laufwerkbuchstaben findet unter Windows-Explorer heraus</li>
<li>Klick auf &quot;Write&quot;</li>
<li>Klick auf &quot;Yes&quot;</li>
</ol>
<p>Wartet nun, bis der Schreibvorgang fertig abgeschlossen wurde.</p>
<h2>Einrichtung auf dem Pi</h2>
<p>Steckt die SD-Karte, ein Netzwerkkabel und das Stromkabel in euren Pi und bootet.
Hat Alles funktioniert, könnt ihr nach ein paar Sekunden euch über SSH mit eurem
Raspberry Pi verbinden. Wie das geht, steht hier: <a href="introduction/ssh.html">SSH-Verbindung</a>.</p>
<pre><code>Benutzer: pi
Passwort: raspberry
</code></pre>
<p>Zu Erst werden einige grundlegende Einstellungen vorgenommen und Programme installiert.<br />
All dies wird als Root-Benutzer ausgeführt:</p>
<pre><code>sudo -i
</code></pre>
<p>Update der Software auf dem Pi (kann eine Weile dauern):</p>
<pre><code>apt-get update -y &amp;&amp; apt-get upgrade -y
apt-get install -y git
</code></pre>
<p>Konfigurieren mit &quot;raspi-config&quot;:</p>
<pre><code>raspi-config
</code></pre>
<p>Ihr navigiert mit den Pfeiltasten und bestätigt mit der Entertaste. Mit Escape
kommt ihr ein Menü zurück.</p>
<ol>
<li>Wähle &quot;1 Expand Filesystem&quot;</li>
<li>Bestätige mit OK</li>
</ol>
<ol>
<li>Wähle &quot;3 Boot Options&quot;</li>
<li>Wähle &quot;B2 Console Autologin&quot;<br />
<em>Der Pi startet dann in der Konsole und ihr seit bereits eingeloggt</em></li>
</ol>
<ol>
<li>Wähle &quot;8 Advanced Options&quot;</li>
<li>Wähle &quot;A6 SPI&quot;</li>
<li>Wähle &quot;Yes&quot;<br />
<em>SPI ist aktiviert, das ist eine Schnittstelle die z.B. für das LCD Tutorial
benötigt wird</em></li>
<li>Bestätige mit OK</li>
<li>Wähle &quot;Yes&quot;<br />
<em>SPI ist nun auch beim nächsten Neustart aktiv</em></li>
<li>Bestätige mit OK</li>
<li>Wähle &quot;Finish&quot; oder Drücke die Escape-Taste um zu Beenden</li>
</ol>
<p><strong>Startet nun den Raspberry Pi neu!</strong></p>
<h1>Software</h1>
<h2>C++ Bibliotheken</h2>
<p>Nun wollen wir die benötigten C++ Bibliotheken installiern, die zum
Zugreifen auf die GPIO-Schnittstelle benötigt werden.</p>
<h3>BCM2835</h3>
<p>Diese Bibliothek ist die Grundlage für alle weiteren GPIO Bibliotheken.
Um sie zu installieren, führt ihr folgendes in der Konsole aus.</p>
<pre><code># Ordner erstellen
cd ~
mkdir libs
cd libs

# Download und Entpacken
wget http://www.airspayce.com/mikem/bcm2835/bcm2835-1.46.tar.gz
tar xzvf bcm2835-1.46.tar.gz
cd bcm2835-1.46

# Konfigurieren, Kompilieren, Installieren
./configure
make
sudo make check
sudo make install
</code></pre>
<h3>GPIO</h3>
<p>Mit dieser Bibliothek wird das verwenden von Pins erheblich erleichtert,
deswegen sollte sie installiert werden:</p>
<pre><code>cd ~/libs

# Download
git clone https://github.com/stormarnschule/gpio.git
cd gpio

# Kompiliern und Installieren
make
sudo make install
</code></pre>
<h1>Grundlagen</h1>
<p>Hier werden dir alle grundsätzlichen Dinge zur allen Bauteilen erläutert, die wir hier verwenden.</p>
<p>Wer sich bereits gut genug über den Raspberry Pi, die Pins und das Gertboard informiert fühlt, kann direkt zu den
Tutorials springen.</p>
<h1>Raspberry Pi</h1>
<h2>Hardware</h2>
<p>Je nach Version des Raspberry Pi unterscheidet sich seine Hardware. Da ihr aber warscheinlich mit der
2. Generation Model B arbeiten werdet, hier ein paar Eckdaten dazu:</p>
<ul>
<li>900 MHz 4 Kern ARM Prozessor (32 bit)</li>
<li>1024 MB Arbeitsspeicher</li>
<li>microSD-Kartenleser als Festplatte</li>
<li>4 USB 2.0 Anschlüsse</li>
<li>40 Pins, davon 26 GPIO</li>
<li>5 V Micro-USB Netzteil</li>
</ul>
<h2>Software</h2>
<p>Als Software kann jedes Betriebssystem verwendet werden, welches auf ARM Prozessorn läuft.<br />
Am häufigsten wird Raspbian benutzt, ein Debian-Linux, aber grundsätzlich kann jedes Linux verwendet werden,
Raspbian bietet jedoch die beste Unterstützung.</p>
<p>Neben Linux kann auch Android installiert werden, allerdings ist dies noch in der Testphase.<br />
Auch neurere Versionen von Windows 10 sind ab RPi 2 Model B kompatibel.</p>
<p>Wir empfehlen auf jeden Fall Raspbian, da dieses Betriebssystem offiziell unterstützt und von den
Raspberry Pi Machern stetigt weiterentwickelt und verbessert wird.</p>
<h1>GPIO</h1>
<h1>Gertboard</h1>
<h1>Tutorials</h1>
<p>Die Tutorials auf den nächsten Seiten werden wie erwähnt in C++ geschrieben.</p>
<p>Um euren Code ausführen zu können, muss er zuerst kompiliert werden, bevor die
Binärdatei gestartet werden kann. Auch die Bibliotheken <code>GPIO</code> und ggf. auch
<code>PCD8544</code> werden eingebunden.</p>
<p>Hierfür könnt ihr unser Script benutzen, dass ihr von GitHub herunterladen könnt.</p>
<pre><code>wget https://raw.githubusercontent.com/stormarnschule/pi-setup/master/run
chmod +x ./run
</code></pre>
<p>Das Script führt ihr wie folgt aus:</p>
<pre><code>./run &lt;cppfile&gt; [OPTIONS]

# cppfile: Pfad zur .cpp-Datei, die ausgeführt werden soll
#
# OPTIONS:
#   -f      Immer kompilieren, auch wenn Binärdatei vorhanden (im Normalfall nicht nötig)
</code></pre>
<h1>Einfach</h1>
<h1>LED</h1>
<h2>Setup</h2>
<p>In diesem Tutorial geht es um eine LED, die mittels des Raspberry Pi's angesteuert und zum blinken gebracht werden soll. Um dies physikalisch zu ermöglichen, muss zunächst eine Verbindung des Pi's mit der LED geschlossen werden. Hierfür benutzen wird ein Schaltboard, auf das die Led gesteckt wird. Der Pi wird nun so mit zwei Kabeln über zwei GPIO-Pins mit dem Schaltboard verbunden, dass ein Stromkreis gebildet wird. Zudem benötigen wir einen in Reihe geschalteten Widerstand, um die Stromstärke zu senken.</p>
<p><img src="img/schaltboard_simple_led.png" alt="LED Setup Schaltboard" /></p>
<h2>Setup-Check</h2>
<p>Wenn ihr euer Schaltboard mit den aufgezählten Elementen versehen habt, könnt ihr euer Setup testen, indem ihr die Kabel die nun vom Schaltboard ausgehen mit dem Dauerstrompin(3,3v, Pin 1) des Pi's und der Erdung(Pin 25) verbindet (siehe Grafik). Achtet darauf, dass eine LED-Diode nur bei einer Stromrichtung den Stromkreislauf schließt. Kommt es daraufhin zu einem Dauerleuchten euer LED, wisst ihr, dass alle Komponenten intakt sind.</p>
<p><img src="img/pi_simple_led.png" alt="Pin Setup" /></p>
<h2>Das Programm</h2>
<p>Nun soll die Led vom Raspberry aus gesteuert werden und nicht durchleuchten, sondern Phasenweise für jeweils 0,5s an und aus sein. Um dies überhaupt zu ermöglichen, muss noch eine kleine Änderung an eurer Hardware vorgenommen werden. Die Verbindung am Dauerstrompin muss aufgelöst werden und das Kabel muss mit an einen der GPIO-Pins verbunden werden. Wir nutzen für dieses Programm den GPIO Pin 15 (siehe Grafik). Diesen Pin könnt ihr mit dem Raspberry Pi ansteuern und an- bzw. ausschalten, also eine Spannung anlegen oder nicht anlegen.
Schreibt nun ein Programm, welches die LED 10 mal für 0,5s leuchten lässt.</p>
<h2>Tipps</h2>
<ol>
<li>Die Gpio-Klasse erleichtert das Arbeiten mit den Pins erheblich. Erfindet also das Rad nicht neu und importiert diese zu Anfang <code>#include &quot;gpio.h&quot;</code>. Es ist jetzt möglich Input- und Output-Pins allein mit der Übergabe der Pinnummer zu definieren.<br />
Ihr braucht außerdem eine Hauptmethode <code>int main()</code>. Diese wird bei Programmstart ausgeführt. In ihr könnt Ihr euer Programm implementieren.</li>
<li>Zuerst muss der Pin 15 als Output-Pin definiert werden. Erzeugt also ein Pin-Objekt über die <code>output_pin</code> Methode in der Gpio-Klasse.</li>
<li>Das zehnfache aufleuchten könnt ihr mir einer <code>for</code>-Schleife umsetzen.</li>
<li>Den Pin-Status kann mit der Methode <code>set_state(bool)</code> verändert werden.</li>
<li>Mit der Methode <code>delay()</code> wird das Programm für die Zeitdauer der übergebenden Zahl in ms pausiert.</li>
</ol>
<h1>Taster</h1>
<h2>Setup</h2>
<p>Bei diesem Tutorial soll eine LED über einen Button angeschaltet werden. Auf Knopfdruck, soll diese so zum Aufleuchten gebracht werden. Wird der Taster wieder losgelassen soll die LED erlöschen. Hierfür wird wie beim Simple-LED Tutorial ein Schaltboard benötigt. Auf diesem werden zwei Stromkreise installiert. Der eine soll die LED mitsamt Widerstand enthalten. Der andere Stromkreis enthält den Button. (Die Funktionsweise lässt sich auch mit einem Stromkreis ohne Programm umsetzen, erfüllt jedoch nicht die Vorraussetzungen, welche für die nächsten Tutorials benötigt werden.) Beide Stromkreise werden jeweils einem GPIO-Pin zugeordnet und mit dem Grund verbunden (In der Lösung wurden der Pin 14 für den Button und Pin 15 für die LED genutzt).</p>
<p><img src="img/simple_button_board.png" alt="Button Schaltboard" />
<img src="img/simple_button_pins.png" alt="Button Pins" /></p>
<h2>Das Programm</h2>
<p>Euer Programm soll über den Button Pin den Status des Knopfdruckes abfragen und je nach diesem die LED über den LED-Pin aufleuchten bzw. nicht aufleuchten lassen.</p>
<h2>Tipps</h2>
<h3>1.</h3>
<p>Über while-Schleifen kann dauerhaft die Status des Buttons geprüft werden. Zum Abfragen könnt ihr die Methode <code>state()</code> nutzen.</p>
<h1>Gertboard</h1>
<h1>Lichtorgel</h1>
<h2>Setup</h2>
<p>Nun zum ersten Tutorial mit dem Gertboard. Deine Aufgabe ist es nun die
eingebaute LED-Reihe in eine Lichtorgel zu verwandeln. Da bei der Lichtorgel
alle LEDs angesteuert werden sollen und diese eine Ausgabe des Pi bzw. des
Gertbords ist, müssen alle Buffer auf dem Gertboard ebenfalls als output
gesetzt sein. Dies betrifft als output Buffer B1 – B12 (siehe Gertboardgrafik).</p>
<p>Habt ihr die Buffer richtig definiert, kann erstmal gar nichts passieren. Es
gibt keine leitende Verbindung zwischen dem funktionellem Block der Buffer und
dem Pi. Diese Verbindung muss nun geschaffen werden. Hierzu müssen die GP Pins
mit den Buffer Pins verbunden werden.<br />
Um die LED wie gewünscht ansteuern zu können sind die GP25–GP17 mit den Buffern
B1-B7 zu verbinden und GP11-GP7 mit B8-B12. GP15 und GP 14 werden ausgelassen,
da diese eine andere Funktion abdecken, die zu diesem Zeitpunkt nicht benötigt
wird. Nach dem verkabeln des Gertboards sollte dieses aussehen wie auf der
Grafik und den Bildern unten auf der Seite.</p>
<p><img src="img/gertboard_lights_1.png" alt="Gertboard Schema" />
<img src="img/gertboard_lights_2.png" alt="Gertboard GPIO Header" />
<img src="img/gertboard_lights_3.png" alt="Gertboard Übersicht" /></p>
<h2>Das Programm</h2>
<p>Nun haben wir bereits die “Hardware”-Vorraussetzungen für unsere Lichtorgel
geschaffen. Wichtig ist, dass ihr die GPIO-Steuerung in euer Programm
einbindet:</p>
<pre><code class="language-cpp">#include &lt;gpio.h&gt;
</code></pre>
<p>Kommen wir nun zum Code, der die Lichtorgel
antreibt. Wichtig ist, dass die API, also die Schnittstelle
eingebunden ist, die den Zugriff auf die GPIO Pins ermöglicht. Diese hält
Methoden bereit, die ihr nun nutzen könnt um die LEDs auf dem Board an und aus
zu schalten.</p>
<p>Euer Programm soll die LEDs auf dem Gerdboard der Reihe nach aufleuchten lassen.
Nachdem eine Richtung komplett durchlaufen wurde, soll dies erneut in die
andere Richtung geschehen. So entsteht eine nicht aufhörende Kette von
aufleutenden Lampen.</p>
<h1>Tipps</h1>
<ol>
<li>Zuerst muss eine Liste von GPIO Pins erstellt werden. Diese sollte alle Pins enthalten die in Verbindung mit den LEDs stehen und diese als <code>output_pin</code> deklarieren.</li>
<li>Um das aufleuchten der Lampen zu einer Lichtorgel zu verbinden benötigt ihr 3 Schleifen.
Davon dient zwei nur zum Aufleuchten einer Reihe in jeweils verschiedene Richtungen. Die dritte dient dazu, dass dieser Vorgang wieder von vorne beginnt.</li>
<li>Funktionen die genutzt werden sollten sind: <code>vector::begin()</code>, <code>vector::end()</code>, <code>pin::state()</code>, <code>delay()</code>.</li>
<li>Mit der Funktion <code>state()</code> kann sowohl ein Wert abgefragt, mit der <code>set_state(bool)</code> übergegen werden.</li>
</ol>
<h1>Taster</h1>
<h2>Setup</h2>
<p>Da in diesem Turorial zum ersten Mal die Taster auf dem Gertboard eingebunden
werden sollen und diese eine Eingabe darstellen werden, muss die Verkabelung
der Pins erneut verändert werden.<br />
Auf die Output Pins B1-B3 müssen Jumper gesetzt werden. Dies ermöglicht eine
Ausgabe des Gertboardboard ausgelöst durch die Taster. Außerdem müssen die GPIO
Pins 25 mit B1, 24 mit B2 und 23 mit B1 verbunden werden.</p>
<p>Dies sieht dann ungefähr so aus:</p>
<p><img src="img/gertboard_buttons.jpg" alt="Gertboard Anschlüsse" /></p>
<h2>Das Programm</h2>
<p>Euer Programm soll nun den Status der Buttons anzeigen. Hierbei sollt ihr alle
drei Buttons einbinden und eine Ausgabe formulieren, über die dem Nutzer
mitgeteilt wird, ob ein Button gedrückt ist oder nicht.</p>
<h2>Tipps</h2>
<ol>
<li>Es muss eine Liste der Pins angelegt werden, über die die Buttons
angesteuert werden, bzw. über die deren Signal geleitet wird. Diese soll
gleichzeitig die Pins als <code>button_pin</code> deklarieren. Ihr erstellt also eine
Liste von den <code>button_pin</code>s. Mit dieser Liste könnt ihr dann im folgenden arbeiten.</li>
<li>Die Liste muss durchgegangen werden und von jedem Pin soll der Status
ermittelt werden. Diesen könnt ihr in einer Variablen speichern und ausgeben lassen.</li>
<li>Um immer den aktuellen Status eines Buttons ermitteln, müssen sich eure
Statusabfragen und Ausgaben in einer <code>while</code>-Schleife befinden.</li>
<li>Der Übersichtlichkeit halber solltet ihr die ausgegebene Zeile zu Beginn der
Schleife wieder löschen. Nutzt dafür <code>std::cout &lt;&lt; &quot;\r&quot;;</code>.</li>
</ol>
<h1>Lichtorgel + Taster</h1>
<h1>LCD</h1>
<h1>Spiel: Snake</h1>
<h2>Setup</h2>
<p>Um ein Spiel über euren Raspberry Pi umzusetzen benötigt ihr nicht nur die Verbindung eines Displays zum Pi (<a href="./index.html">LCD Display</a>), sondern auch eine Verbindung zu Eingabegeräten, in diesem Fall Buttons, die auf einem Schaltboard angebracht werden. Von den Buttons aus muss eine Verbindung zu jeweils einem  Gpio Pin geschlossen werden, über den dann der Status später abgefragt werden soll (viele Möglichkeiten des Anschlusses gilt es nicht, da die meisten Pins bereits durch das LCD Display belegt sind, in unserem Beispiel für das Programm wurden die Pins 24 und 25 benutzt). Um den Button auch tatsächlich in einen Stromkreislauf einzubauen, muss ein Kabel vom Grund zum Button und ein weiteres vom Button weg zu dem gewünschten Gpio-Pin laufen, sodass dieser mit einem Tastendruck den Kreislauf schließt und ein Potentialunterschied erfasst werden kann.</p>
<p><img src="img/lcd_snake_all.png" alt="Snake Setup" />
<img src="img/lcd_snake_pins.png" alt="Snake Game Pins" />
<img src="img/lcd_snake_buttons.png" alt="Snake Game Buttons" /></p>
<h2>Das Programm</h2>
<p>Es soll ein Standart Snake Spiel, wie es früher auf Mobiltelefonen lief, über den Pi realisiert werden.
Folgende Eigenschaften und Elemente sollen enthalten sein:</p>
<ul>
<li>Eine Schlange mit einer bestimmten Anfangsgröße, die mittels zweier Buttons vom Spieler gesteuert werden kann und sich mit konstanter Geschwindikeit vorwärts bewegt</li>
<li>Richtungsänderungen geschehen immer im 90°-Winkel. Gleichmäßige Bewegungen sind nicht möglich</li>
<li>Zufällig erscheinendes Futter, welches die Schlange vergrößert, wenn sie es frisst (über den Punkt läuft)</li>
<li>Abbruch des Spiel, wenn die Schlange gegen sich selbst läuft</li>
<li>Ein grafisch festgehaltenes Spielfeld mit einer Anzeige für den Score</li>
</ul>
<p><img src="img/lcd_snake_run.png" alt="Snake Game Running" /></p>
<h2>Tipps</h2>
<h3>1.</h3>
<p>Geht in logischen Schritten an das Projekt heran. Überlegt, wie in der OOP, welche Eigenschaften die Snake eigentlich haben soll (obwohl ihr nicht zwangsweise eine eigene Klasse für diese anlegen müsst). Legt darauf basiert Methoden fest, die diese Eigenschaften definieren. Des weiteren könnt ihr das gesamte Programm in Methoden aufteilen, die den Spielablauf wiederspiegeln. Methoden könnten sein:</p>
<ul>
<li><code>init()</code> oder <code>gameStart()</code> - deklariert die Startbedingungen</li>
<li><code>move()</code> - beschreibt das Bewegen der Snake</li>
<li><code>input()</code> - setzt die Eingaben um</li>
<li><code>draw_header()</code> - beschreibt das Spielfeld</li>
<li><code>render()</code> - aktualisiert das Spiel auf dem Display</li>
</ul>
<h3>2.</h3>
<p>Wenn ihr möglich frühzeitig eure Programmabschnitte testen wollt gibt es dafür 2 Möglichkeiten:</p>
<ol>
<li>Ihr baut Konsolenausgaben in die Bereich ein, über die ihr euch nicht sicher seit, ob und in welcher Reihenfolge die ausgeführt werden.</li>
<li>Beschreibt erstmal das grafische Spielfeld (geht dabei vor wie im LCD_Tutorial). Außerdem müsst ihr dann noch eine Render()-Methode definiert, die in regelmäßigen Abständen euren derzeitigen Spielstatus graphisch darstellt. Auf diese Weise könnt ihr nach jeder Programmerweiterung Fortschritte auch Bildlich erkennen. Gleichzeitig vermeidet diese Vorgehensweise ein umfangreichen, langes Debuggen zu späteren Entwicklungsstati.</li>
</ol>
<h3>3.</h3>
<p>Ignoriert zunächst, dass ihr etwas grafisches programmiert. Beschreibt das Verhalten der Schlange anhand von Koordinaten, die ihr als Punkt in einem X- und einem Y-Wert (Startpunkt + konstante Änderung der Koordinaten für eine gleichförmige Bewegung). Beschreibt erstmal eine gradlinige Bewegung und kümmert euch erst später um Inputs. Dies setzt voraus, dass die Schlange nach dem passieren des rechten Bildschirmrandes wieder links eintritt.
Das Einzige, was euch nun noch von einer graphischen Umsetzung trennt, ist die Eindung der Schlangenposition in die render() Methode.</p>
<h3>4.</h3>
<p>In vielen Bereichen müssen Zwischenstände, sowie Zustände festgehalten werden. Überlegt euch hierfür sinnvolle Variablen.</p>
<h2>Erweiterungen</h2>
<p>Wenn ihr das Snake Spiel erfolgreich umgesetzt habt, könnt ihr euch Erweiterungen für dieses Überlegen, welche das Spiel unter Umständen interessanter gestalten könnten. Als Beispiel-Code liegen 2 weitere Versionen des Spiels vor. Jeweils wurde das Setup um zwei Buttons ergänzt. Beim einen werden diese für eine abweichende Steuerung der Snake genutzt, die andere Variante ermöglicht durch diese die Steuerung einer weiteren Snake für ein Zweispielerduell.</p>
<h1>Meta</h1>
<p>Hier möchte ich kurz erläutern, wie diese Dokumentation erstellt wird, damit
nachfolgende Schüler oder Lehrer sie erweitern können, bei Bedarf.</p>
<h2>Aufbau</h2>
<p>Diese Webseite besteht aus HTML, CSS und JavaScript Dateien, die alle auf einem
Server für alle zugäglich liegen.</p>
<p>Anstatt diese Dokumentation direkt in HTML zu schreiben, verwenden wir einen
Werkzeug, was häufig zum Schreiben von statischen Webseiten oder Blogs benutzt
wird: <a href="http://commonmark.org/help/"><strong>Markdown</strong></a>. Markdown ist eine, einfachem
Text sehr ähnliche Sprache, in der man formatierten Text schnell und gut lesbar
scheiben kann.</p>
<h2>Kompilieren</h2>
<p>Da allerdings der Webbrowser Markdown - anders als HTML - nicht rendern kann,
wird es vorher von einem Programm in HTML übersetzt, &quot;kompiliert&quot;.</p>
<p>Wir benutzen hierfür <a href="http://azerupi.github.io/mdBook/"><strong>mdBook</strong></a>. Es ist
sehr einfach in der Verwendung und, im Vergleich zu Ähnlichem, <em>sehr schnell</em>.</p>
<h2>Hosting</h2>
<p>Der Markdown-Code für dieses Buch findet ihr in unserem
<a href="http://github.com/stormarnschule/raspi-book"><strong>GitHub-Repo</strong></a>.</p>
<p>Bei jedem Commit, also immer dann, wenn wir etwas geändert haben, wird der Code
automatisch nach HTML kompiliert. Die erstellte Webseite befindet sich
im <a href="https://github.com/stormarnschule/raspi-book/tree/gh-pages"><strong>gh-pages</strong></a>
Zweig vom selben Repo.<br />
Hierfür gebrauchen wir die WebApp <a href="http://wercker.com">wercker.com</a>.</p>
<p>Wenn man nun im Browser auf die Webseite
<a href="http://stormarnschule.github.io/raspi-book"><strong>stormarnschule.github.io/raspi-book</strong></a>
geht, sendet GitHub eben jenen HTML-Code, der im gh-pages Zweig liegt an den
WebBrowser.</p>
<h2>Bilder</h2>
<p>Die Bilder sind alle im PNG Format, dies bietet die beste Qualität bei kleiner
Dateigröße. Im Gegensatz zu JPG sieht man keine Pixelfehler oder &quot;Krisel&quot;.</p>
<p>Alle Bilder wurden auf eine Breite von <code>750 px</code> skaliert, so passen sie genau
auf eine Seite, ohne vom Browser verkleinert werden zu müssen. Außerdem benutzen
einige Bilder <a href="https://de.wikipedia.org/wiki/Adam7">Adam7</a>, ein Algorithmus der
während es Herunterladens das Bild verfeinert.<br />
Die Verwendung von Adam7 ist von uns <strong>empfohlen</strong>!</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
